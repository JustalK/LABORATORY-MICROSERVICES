"use strict";
exports.__esModule = true;
exports.Helpers = void 0;
var Helpers = /** @class */ (function () {
    function Helpers(faker) {
        this.faker = faker;
        // Bind `this` so namespaced is working correctly
        for (var _i = 0, _a = Object.getOwnPropertyNames(Helpers.prototype); _i < _a.length; _i++) {
            var name_1 = _a[_i];
            if (name_1 === 'constructor' || typeof this[name_1] !== 'function') {
                continue;
            }
            this[name_1] = this[name_1].bind(this);
        }
    }
    /**
     * backward-compatibility
     *
     * @method faker.helpers.randomize
     * @param array
     */
    Helpers.prototype.randomize = function (array) {
        if (array === void 0) { array = ['a', 'b', 'c']; }
        return this.faker.random.arrayElement(array);
    };
    /**
     * slugifies string
     *
     * @method faker.helpers.slugify
     * @param string
     */
    Helpers.prototype.slugify = function (string) {
        if (string === void 0) { string = ''; }
        return string
            .replace(/ /g, '-')
            .replace(/[^\一-龠\ぁ-ゔ\ァ-ヴー\w\.\-]+/g, '');
    };
    /**
     * Parses string for a symbol and replace it with a random number from 1-10
     *
     * @method faker.helpers.replaceSymbolWithNumber
     * @param string
     * @param symbol defaults to `"#"`
     */
    Helpers.prototype.replaceSymbolWithNumber = function (string, symbol) {
        if (string === void 0) { string = ''; }
        if (symbol === void 0) { symbol = '#'; }
        var str = '';
        for (var i = 0; i < string.length; i++) {
            if (string.charAt(i) == symbol) {
                str += this.faker.datatype.number(9);
            }
            else if (string.charAt(i) == '!') {
                str += this.faker.datatype.number({ min: 2, max: 9 });
            }
            else {
                str += string.charAt(i);
            }
        }
        return str;
    };
    /**
     * Parses string for symbols (numbers or letters) and replaces them appropriately (# will be replaced with number,
     * ? with letter and * will be replaced with number or letter)
     *
     * @method faker.helpers.replaceSymbols
     * @param string
     */
    Helpers.prototype.replaceSymbols = function (string) {
        if (string === void 0) { string = ''; }
        var alpha = [
            'A',
            'B',
            'C',
            'D',
            'E',
            'F',
            'G',
            'H',
            'I',
            'J',
            'K',
            'L',
            'M',
            'N',
            'O',
            'P',
            'Q',
            'R',
            'S',
            'T',
            'U',
            'V',
            'W',
            'X',
            'Y',
            'Z',
        ];
        var str = '';
        for (var i = 0; i < string.length; i++) {
            if (string.charAt(i) == '#') {
                str += this.faker.datatype.number(9);
            }
            else if (string.charAt(i) == '?') {
                str += this.faker.random.arrayElement(alpha);
            }
            else if (string.charAt(i) == '*') {
                str += this.faker.datatype.boolean()
                    ? this.faker.random.arrayElement(alpha)
                    : this.faker.datatype.number(9);
            }
            else {
                str += string.charAt(i);
            }
        }
        return str;
    };
    /**
     * replace symbols in a credit card schems including Luhn checksum
     *
     * @method faker.helpers.replaceCreditCardSymbols
     * @param string
     * @param symbol
     */
    Helpers.prototype.replaceCreditCardSymbols = function (string, symbol) {
        // default values required for calling method without arguments
        if (string === void 0) { string = '6453-####-####-####-###L'; }
        if (symbol === void 0) { symbol = '#'; }
        // Function calculating the Luhn checksum of a number string
        var getCheckBit = function (number) {
            number.reverse();
            number = number.map(function (num, index) {
                if (index % 2 === 0) {
                    num *= 2;
                    if (num > 9) {
                        num -= 9;
                    }
                }
                return num;
            });
            var sum = number.reduce(function (prev, curr) { return prev + curr; });
            return sum % 10;
        };
        string = this.faker.helpers.regexpStyleStringParse(string); // replace [4-9] with a random number in range etc...
        string = this.faker.helpers.replaceSymbolWithNumber(string, symbol); // replace ### with random numbers
        var numberList = string
            .replace(/\D/g, '')
            .split('')
            .map(function (num) { return parseInt(num); });
        var checkNum = getCheckBit(numberList);
        // TODO @Shinigami92 2022-01-11: I assume this should be converted to string
        // @ts-expect-error
        return string.replace('L', checkNum);
    };
    /**
     * String repeat helper, alternative to String.prototype.repeat.... See PR #382
     *
     * @method faker.helpers.repeatString
     * @param string
     * @param num
     */
    Helpers.prototype.repeatString = function (string, num) {
        if (num === void 0) { num = 0; }
        var text = '';
        for (var i = 0; i < num; i++) {
            text += string.toString();
        }
        return text;
    };
    /**
     * parse string patterns in a similar way to RegExp
     *
     * e.g. "#{3}test[1-5]" -> "###test4"
     *
     * @method faker.helpers.regexpStyleStringParse
     * @param string
     */
    Helpers.prototype.regexpStyleStringParse = function (string) {
        if (string === void 0) { string = ''; }
        // Deal with range repeat `{min,max}`
        var RANGE_REP_REG = /(.)\{(\d+)\,(\d+)\}/;
        var REP_REG = /(.)\{(\d+)\}/;
        var RANGE_REG = /\[(\d+)\-(\d+)\]/;
        var min, max, tmp, repetitions;
        var token = string.match(RANGE_REP_REG);
        while (token !== null) {
            min = parseInt(token[2]);
            max = parseInt(token[3]);
            // switch min and max
            if (min > max) {
                tmp = max;
                max = min;
                min = tmp;
            }
            repetitions = this.faker.datatype.number({ min: min, max: max });
            string =
                string.slice(0, token.index) +
                    this.faker.helpers.repeatString(token[1], repetitions) +
                    string.slice(token.index + token[0].length);
            token = string.match(RANGE_REP_REG);
        }
        // Deal with repeat `{num}`
        token = string.match(REP_REG);
        while (token !== null) {
            repetitions = parseInt(token[2]);
            string =
                string.slice(0, token.index) +
                    this.faker.helpers.repeatString(token[1], repetitions) +
                    string.slice(token.index + token[0].length);
            token = string.match(REP_REG);
        }
        // Deal with range `[min-max]` (only works with numbers for now)
        //TODO: implement for letters e.g. [0-9a-zA-Z] etc.
        token = string.match(RANGE_REG);
        while (token !== null) {
            min = parseInt(token[1]); // This time we are not capturing the char before `[]`
            max = parseInt(token[2]);
            // switch min and max
            if (min > max) {
                tmp = max;
                max = min;
                min = tmp;
            }
            string =
                string.slice(0, token.index) +
                    this.faker.datatype.number({ min: min, max: max }).toString() +
                    string.slice(token.index + token[0].length);
            token = string.match(RANGE_REG);
        }
        return string;
    };
    /**
     * Takes an array and randomizes it in place then returns it
     *
     * Uses the modern version of the Fisher–Yates algorithm
     *
     * @method faker.helpers.shuffle
     * @param o
     */
    Helpers.prototype.shuffle = function (o) {
        if (typeof o === 'undefined' || o.length === 0) {
            return o || [];
        }
        o || (o = ['a', 'b', 'c']);
        for (var x = void 0, j = void 0, i = o.length - 1; i > 0; --i) {
            j = this.faker.datatype.number(i);
            x = o[i];
            o[i] = o[j];
            o[j] = x;
        }
        return o;
    };
    /**
     * Takes an array of strings or function that returns a string
     * and outputs a unique array of strings based on that source
     *
     * @example uniqueArray(faker.random.word, 50)
     * @example uniqueArray(faker.definitions.name.first_name, 6)
     * @example uniqueArray(["Hello", "World", "Goodbye"], 2)
     *
     * @method faker.helpers.uniqueArray
     * @param source
     * @param length
     */
    Helpers.prototype.uniqueArray = function (source, length) {
        if (Array.isArray(source)) {
            var set_1 = new Set(source);
            var array = Array.from(set_1);
            return this.faker.helpers.shuffle(array).splice(0, length);
        }
        var set = new Set();
        try {
            if (typeof source === 'function') {
                while (set.size < length) {
                    set.add(source());
                }
            }
        }
        finally {
            return Array.from(set);
        }
    };
    /**
     * mustache
     *
     * @method faker.helpers.mustache
     * @param str
     * @param data
     */
    Helpers.prototype.mustache = function (str, data) {
        if (typeof str === 'undefined') {
            return '';
        }
        for (var p in data) {
            var re = new RegExp('{{' + p + '}}', 'g');
            str = str.replace(re, 
            // TODO christopher 2022-01-14: Try to improve the type or maybe use `if`
            // @ts-expect-error
            data[p]);
        }
        return str;
    };
    // TODO @Shinigami92 2022-01-11: We might have a bug with the `phone` definition
    // I may be `phone_number` instead
    /**
     * createCard
     *
     * @method faker.helpers.createCard
     */
    Helpers.prototype.createCard = function () {
        return {
            name: this.faker.name.findName(),
            username: this.faker.internet.userName(),
            email: this.faker.internet.email(),
            address: {
                streetA: this.faker.address.streetName(),
                streetB: this.faker.address.streetAddress(),
                streetC: this.faker.address.streetAddress(true),
                streetD: this.faker.address.secondaryAddress(),
                city: this.faker.address.city(),
                state: this.faker.address.state(),
                country: this.faker.address.country(),
                zipcode: this.faker.address.zipCode(),
                geo: {
                    lat: this.faker.address.latitude(),
                    lng: this.faker.address.longitude()
                }
            },
            phone: this.faker.phone.phoneNumber(),
            website: this.faker.internet.domainName(),
            company: {
                name: this.faker.company.companyName(),
                catchPhrase: this.faker.company.catchPhrase(),
                bs: this.faker.company.bs()
            },
            posts: [
                {
                    words: this.faker.lorem.words(),
                    sentence: this.faker.lorem.sentence(),
                    sentences: this.faker.lorem.sentences(),
                    paragraph: this.faker.lorem.paragraph()
                },
                {
                    words: this.faker.lorem.words(),
                    sentence: this.faker.lorem.sentence(),
                    sentences: this.faker.lorem.sentences(),
                    paragraph: this.faker.lorem.paragraph()
                },
                {
                    words: this.faker.lorem.words(),
                    sentence: this.faker.lorem.sentence(),
                    sentences: this.faker.lorem.sentences(),
                    paragraph: this.faker.lorem.paragraph()
                },
            ],
            accountHistory: [
                this.faker.helpers.createTransaction(),
                this.faker.helpers.createTransaction(),
                this.faker.helpers.createTransaction(),
            ]
        };
    };
    /**
     * contextualCard
     *
     * @method faker.helpers.contextualCard
     */
    Helpers.prototype.contextualCard = function () {
        var name = this.faker.name.firstName(), userName = this.faker.internet.userName(name);
        return {
            name: name,
            username: userName,
            avatar: this.faker.internet.avatar(),
            email: this.faker.internet.email(userName),
            dob: this.faker.date.past(50, 
            // TODO @Shinigami92 2022-01-14: We may need to convert this to a string
            // @ts-expect-error
            new Date('Sat Sep 20 1992 21:35:02 GMT+0200 (CEST)')),
            phone: this.faker.phone.phoneNumber(),
            address: {
                street: this.faker.address.streetName(),
                suite: this.faker.address.secondaryAddress(),
                city: this.faker.address.city(),
                zipcode: this.faker.address.zipCode(),
                geo: {
                    lat: this.faker.address.latitude(),
                    lng: this.faker.address.longitude()
                }
            },
            website: this.faker.internet.domainName(),
            company: {
                name: this.faker.company.companyName(),
                catchPhrase: this.faker.company.catchPhrase(),
                bs: this.faker.company.bs()
            }
        };
    };
    /**
     * userCard
     *
     * @method faker.helpers.userCard
     */
    Helpers.prototype.userCard = function () {
        return {
            name: this.faker.name.findName(),
            username: this.faker.internet.userName(),
            email: this.faker.internet.email(),
            address: {
                street: this.faker.address.streetName(),
                suite: this.faker.address.secondaryAddress(),
                city: this.faker.address.city(),
                zipcode: this.faker.address.zipCode(),
                geo: {
                    lat: this.faker.address.latitude(),
                    lng: this.faker.address.longitude()
                }
            },
            phone: this.faker.phone.phoneNumber(),
            website: this.faker.internet.domainName(),
            company: {
                name: this.faker.company.companyName(),
                catchPhrase: this.faker.company.catchPhrase(),
                bs: this.faker.company.bs()
            }
        };
    };
    /**
     * createTransaction
     *
     * @method faker.helpers.createTransaction
     */
    Helpers.prototype.createTransaction = function () {
        return {
            amount: this.faker.finance.amount(),
            date: new Date(2012, 1, 2),
            business: this.faker.company.companyName(),
            name: [this.faker.finance.accountName(), this.faker.finance.mask()].join(' '),
            type: this.randomize(this.faker.definitions.finance.transaction_type),
            account: this.faker.finance.account()
        };
    };
    return Helpers;
}());
exports.Helpers = Helpers;
/*
String.prototype.capitalize = function () { //v1.0
    return this.replace(/\w+/g, function (a) {
        return a.charAt(0).toUpperCase() + a.substr(1).toLowerCase();
    });
};
*/
