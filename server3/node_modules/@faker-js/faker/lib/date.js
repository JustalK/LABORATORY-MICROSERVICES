"use strict";
exports.__esModule = true;
exports._Date = void 0;
var _Date = /** @class */ (function () {
    function _Date(faker) {
        this.faker = faker;
        // Bind `this` so namespaced is working correctly
        for (var _i = 0, _a = Object.getOwnPropertyNames(_Date.prototype); _i < _a.length; _i++) {
            var name_1 = _a[_i];
            if (name_1 === 'constructor' || typeof this[name_1] !== 'function') {
                continue;
            }
            this[name_1] = this[name_1].bind(this);
        }
    }
    /**
     * past
     *
     * @method faker.date.past
     * @param years
     * @param refDate
     */
    _Date.prototype.past = function (years, refDate) {
        var date = new Date();
        if (typeof refDate !== 'undefined') {
            date = new Date(Date.parse(refDate));
        }
        var range = {
            min: 1000,
            max: (years || 1) * 365 * 24 * 3600 * 1000
        };
        var past = date.getTime();
        past -= this.faker.datatype.number(range); // some time from now to N years ago, in milliseconds
        date.setTime(past);
        return date;
    };
    /**
     * future
     *
     * @method faker.date.future
     * @param years
     * @param refDate
     */
    _Date.prototype.future = function (years, refDate) {
        var date = new Date();
        if (typeof refDate !== 'undefined') {
            date = new Date(Date.parse(refDate));
        }
        var range = {
            min: 1000,
            max: (years || 1) * 365 * 24 * 3600 * 1000
        };
        var future = date.getTime();
        future += this.faker.datatype.number(range); // some time from now to N years later, in milliseconds
        date.setTime(future);
        return date;
    };
    /**
     * between
     *
     * @method faker.date.between
     * @param from
     * @param to
     */
    _Date.prototype.between = function (from, to) {
        var fromMilli = Date.parse(from);
        var dateOffset = this.faker.datatype.number(Date.parse(to) - fromMilli);
        var newDate = new Date(fromMilli + dateOffset);
        return newDate;
    };
    /**
     * betweens
     *
     * @method faker.date.between
     * @param from
     * @param to
     * @param num
     */
    _Date.prototype.betweens = function (from, to, num) {
        if (typeof num == 'undefined') {
            num = 3;
        }
        var newDates = [];
        var fromMilli = Date.parse(from);
        var dateOffset = (Date.parse(to) - fromMilli) / (num + 1);
        var lastDate = from;
        for (var i = 0; i < num; i++) {
            // TODO @Shinigami92 2022-01-11: It may be a bug that `lastDate` is passed to parse if it's a `Date` not a `string`
            // @ts-expect-error
            fromMilli = Date.parse(lastDate);
            lastDate = new Date(fromMilli + dateOffset);
            newDates.push(lastDate);
        }
        return newDates;
    };
    /**
     * recent
     *
     * @method faker.date.recent
     * @param days
     * @param refDate
     */
    _Date.prototype.recent = function (days, refDate) {
        var date = new Date();
        if (typeof refDate !== 'undefined') {
            date = new Date(Date.parse(refDate));
        }
        var range = {
            min: 1000,
            max: (days || 1) * 24 * 3600 * 1000
        };
        var future = date.getTime();
        future -= this.faker.datatype.number(range); // some time from now to N days ago, in milliseconds
        date.setTime(future);
        return date;
    };
    /**
     * soon
     *
     * @method faker.date.soon
     * @param days
     * @param refDate
     */
    _Date.prototype.soon = function (days, refDate) {
        var date = new Date();
        if (typeof refDate !== 'undefined') {
            date = new Date(Date.parse(refDate));
        }
        var range = {
            min: 1000,
            max: (days || 1) * 24 * 3600 * 1000
        };
        var future = date.getTime();
        future += this.faker.datatype.number(range); // some time from now to N days later, in milliseconds
        date.setTime(future);
        return date;
    };
    /**
     * month
     *
     * @method faker.date.month
     * @param options
     */
    _Date.prototype.month = function (options) {
        options = options || {};
        var type = 'wide';
        if (options.abbr) {
            type = 'abbr';
        }
        if (options.context &&
            typeof this.faker.definitions.date.month[type + '_context'] !==
                'undefined') {
            type += '_context';
        }
        var source = this.faker.definitions.date.month[type];
        return this.faker.random.arrayElement(source);
    };
    /**
     * weekday
     *
     * @method faker.date.weekday
     * @param options
     */
    _Date.prototype.weekday = function (options) {
        options = options || {};
        var type = 'wide';
        if (options.abbr) {
            type = 'abbr';
        }
        if (options.context &&
            typeof this.faker.definitions.date.weekday[type + '_context'] !==
                'undefined') {
            type += '_context';
        }
        var source = this.faker.definitions.date.weekday[type];
        return this.faker.random.arrayElement(source);
    };
    return _Date;
}());
exports._Date = _Date;
