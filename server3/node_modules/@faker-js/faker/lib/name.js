"use strict";
exports.__esModule = true;
exports.Name = void 0;
var Name = /** @class */ (function () {
    function Name(faker) {
        this.faker = faker;
        // Bind `this` so namespaced is working correctly
        for (var _i = 0, _a = Object.getOwnPropertyNames(Name.prototype); _i < _a.length; _i++) {
            var name_1 = _a[_i];
            if (name_1 === 'constructor' || typeof this[name_1] !== 'function') {
                continue;
            }
            this[name_1] = this[name_1].bind(this);
        }
    }
    /**
     * firstName
     *
     * @method faker.name.firstName
     * @param gender
     * @memberof faker.name
     */
    Name.prototype.firstName = function (gender) {
        if (typeof this.faker.definitions.name.male_first_name !== 'undefined' &&
            typeof this.faker.definitions.name.female_first_name !== 'undefined') {
            // some locale datasets ( like ru ) have first_name split by gender. since the name.first_name field does not exist in these datasets,
            // we must randomly pick a name from either gender array so faker.name.firstName will return the correct locale data ( and not fallback )
            if (typeof gender === 'string') {
                if (gender.toLowerCase() === 'male') {
                    gender = 0;
                }
                else if (gender.toLowerCase() === 'female') {
                    gender = 1;
                }
            }
            if (typeof gender !== 'number') {
                if (typeof this.faker.definitions.name.first_name === 'undefined') {
                    gender = this.faker.datatype.number(1);
                }
                else {
                    // Fall back to non-gendered names if they exist and gender wasn't specified
                    return this.faker.random.arrayElement(this.faker.definitions.name.first_name);
                }
            }
            if (gender === 0) {
                return this.faker.random.arrayElement(this.faker.definitions.name.male_first_name);
            }
            else {
                return this.faker.random.arrayElement(this.faker.definitions.name.female_first_name);
            }
        }
        return this.faker.random.arrayElement(this.faker.definitions.name.first_name);
    };
    /**
     * lastName
     *
     * @method lastName
     * @param gender
     * @memberof faker.name
     */
    Name.prototype.lastName = function (gender) {
        if (typeof this.faker.definitions.name.male_last_name !== 'undefined' &&
            typeof this.faker.definitions.name.female_last_name !== 'undefined') {
            // some locale datasets ( like ru ) have last_name split by gender. i have no idea how last names can have genders, but also i do not speak russian
            // see above comment of firstName method
            if (typeof gender !== 'number') {
                gender = this.faker.datatype.number(1);
            }
            if (gender === 0) {
                return this.faker.random.arrayElement(this.faker.locales[this.faker.locale].name.male_last_name);
            }
            else {
                return this.faker.random.arrayElement(this.faker.locales[this.faker.locale].name.female_last_name);
            }
        }
        return this.faker.random.arrayElement(this.faker.definitions.name.last_name);
    };
    /**
     * middleName
     *
     * @method middleName
     * @param gender
     * @memberof faker.name
     */
    Name.prototype.middleName = function (gender) {
        if (typeof this.faker.definitions.name.male_middle_name !== 'undefined' &&
            typeof this.faker.definitions.name.female_middle_name !== 'undefined') {
            if (typeof gender !== 'number') {
                gender = this.faker.datatype.number(1);
            }
            if (gender === 0) {
                return this.faker.random.arrayElement(this.faker.locales[this.faker.locale].name.male_middle_name);
            }
            else {
                return this.faker.random.arrayElement(this.faker.locales[this.faker.locale].name.female_middle_name);
            }
        }
        return this.faker.random.arrayElement(this.faker.definitions.name.middle_name);
    };
    /**
     * findName
     *
     * @method findName
     * @param firstName
     * @param lastName
     * @param gender
     * @memberof faker.name
     */
    Name.prototype.findName = function (firstName, lastName, gender) {
        var r = this.faker.datatype.number(8);
        var prefix = '', suffix = '';
        // in particular locales first and last names split by gender,
        // thus we keep consistency by passing 0 as male and 1 as female
        if (typeof gender !== 'number') {
            gender = this.faker.datatype.number(1);
        }
        firstName || (firstName = this.faker.name.firstName(gender));
        lastName || (lastName = this.faker.name.lastName(gender));
        switch (r) {
            case 0:
                prefix = this.faker.name.prefix(gender);
                if (prefix) {
                    return prefix + ' ' + firstName + ' ' + lastName;
                }
            case 1:
                suffix = this.faker.name.suffix();
                if (suffix) {
                    return firstName + ' ' + lastName + ' ' + suffix;
                }
        }
        return firstName + ' ' + lastName;
    };
    /**
     * jobTitle
     *
     * @method jobTitle
     * @memberof faker.name
     */
    Name.prototype.jobTitle = function () {
        return (this.faker.name.jobDescriptor() +
            ' ' +
            this.faker.name.jobArea() +
            ' ' +
            this.faker.name.jobType());
    };
    /**
     * gender
     *
     * @method gender
     * @param binary
     * @memberof faker.name
     */
    Name.prototype.gender = function (binary) {
        if (binary) {
            return this.faker.random.arrayElement(this.faker.definitions.name.binary_gender);
        }
        else {
            return this.faker.random.arrayElement(this.faker.definitions.name.gender);
        }
    };
    /**
     * prefix
     *
     * @method prefix
     * @param gender
     * @memberof faker.name
     */
    Name.prototype.prefix = function (gender) {
        if (typeof this.faker.definitions.name.male_prefix !== 'undefined' &&
            typeof this.faker.definitions.name.female_prefix !== 'undefined') {
            if (typeof gender !== 'number') {
                gender = this.faker.datatype.number(1);
            }
            if (gender === 0) {
                return this.faker.random.arrayElement(this.faker.locales[this.faker.locale].name.male_prefix);
            }
            else {
                return this.faker.random.arrayElement(this.faker.locales[this.faker.locale].name.female_prefix);
            }
        }
        return this.faker.random.arrayElement(this.faker.definitions.name.prefix);
    };
    /**
     * suffix
     *
     * @method suffix
     * @memberof faker.name
     */
    Name.prototype.suffix = function () {
        return this.faker.random.arrayElement(this.faker.definitions.name.suffix);
    };
    /**
     * title
     *
     * @method title
     * @memberof faker.name
     */
    Name.prototype.title = function () {
        var descriptor = this.faker.random.arrayElement(this.faker.definitions.name.title.descriptor), level = this.faker.random.arrayElement(this.faker.definitions.name.title.level), job = this.faker.random.arrayElement(this.faker.definitions.name.title.job);
        return descriptor + ' ' + level + ' ' + job;
    };
    /**
     * jobDescriptor
     *
     * @method jobDescriptor
     * @memberof faker.name
     */
    Name.prototype.jobDescriptor = function () {
        return this.faker.random.arrayElement(this.faker.definitions.name.title.descriptor);
    };
    /**
     * jobArea
     *
     * @method jobArea
     * @memberof faker.name
     */
    Name.prototype.jobArea = function () {
        return this.faker.random.arrayElement(this.faker.definitions.name.title.level);
    };
    /**
     * jobType
     *
     * @method jobType
     * @memberof faker.name
     */
    Name.prototype.jobType = function () {
        return this.faker.random.arrayElement(this.faker.definitions.name.title.job);
    };
    return Name;
}());
exports.Name = Name;
